/**
 * Bybit API
 * ## REST API for the Bybit Exchange. Base URI: [https://api.bybit.com]  
 *
 * OpenAPI spec version: 0.2.10
 * Contact: support@bybit.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.8.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "LinearConditionalApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

LinearConditionalApi::LinearConditionalApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

LinearConditionalApi::~LinearConditionalApi()
{
}

pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_cancel(boost::optional<utility::string_t> stopOrderId, boost::optional<utility::string_t> orderLinkId, boost::optional<utility::string_t> symbol)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/cancel");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_cancel does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    if (stopOrderId)
    {
        formParams[ utility::conversions::to_string_t("stop_order_id") ] = ApiClient::parameterToString(*stopOrderId);
    }
    if (orderLinkId)
    {
        formParams[ utility::conversions::to_string_t("order_link_id") ] = ApiClient::parameterToString(*orderLinkId);
    }
    if (symbol)
    {
        formParams[ utility::conversions::to_string_t("symbol") ] = ApiClient::parameterToString(*symbol);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_cancel does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_cancel: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_cancel: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_cancel: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_cancelAll(utility::string_t symbol)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/cancel-all");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_cancelAll does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    {
        formParams[ utility::conversions::to_string_t("symbol") ] = ApiClient::parameterToString(symbol);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_cancelAll does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_cancelAll: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_cancelAll: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_cancelAll: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_getOrders(boost::optional<utility::string_t> stopOrderId, boost::optional<utility::string_t> orderLinkId, boost::optional<utility::string_t> symbol, boost::optional<utility::string_t> order, boost::optional<utility::string_t> page, boost::optional<utility::string_t> limit, boost::optional<utility::string_t> stopOrderStatus)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/list");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_getOrders does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    if (stopOrderId)
    {
        queryParams[utility::conversions::to_string_t("stop_order_id")] = ApiClient::parameterToString(*stopOrderId);
    }
    if (orderLinkId)
    {
        queryParams[utility::conversions::to_string_t("order_link_id")] = ApiClient::parameterToString(*orderLinkId);
    }
    if (symbol)
    {
        queryParams[utility::conversions::to_string_t("symbol")] = ApiClient::parameterToString(*symbol);
    }
    if (order)
    {
        queryParams[utility::conversions::to_string_t("order")] = ApiClient::parameterToString(*order);
    }
    if (page)
    {
        queryParams[utility::conversions::to_string_t("page")] = ApiClient::parameterToString(*page);
    }
    if (limit)
    {
        queryParams[utility::conversions::to_string_t("limit")] = ApiClient::parameterToString(*limit);
    }
    if (stopOrderStatus)
    {
        queryParams[utility::conversions::to_string_t("stop_order_status")] = ApiClient::parameterToString(*stopOrderStatus);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_getOrders does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_getOrders: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_getOrders: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_getOrders: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_new(boost::optional<utility::string_t> symbol, boost::optional<utility::string_t> side, boost::optional<utility::string_t> orderType, boost::optional<double> qty, boost::optional<double> price, boost::optional<double> basePrice, boost::optional<double> stopPx, boost::optional<utility::string_t> timeInForce, boost::optional<utility::string_t> triggerBy, boost::optional<bool> reduceOnly, boost::optional<bool> closeOnTrigger, boost::optional<utility::string_t> orderLinkId, boost::optional<double> takeProfit, boost::optional<double> stopLoss, boost::optional<utility::string_t> tpTriggerBy, boost::optional<utility::string_t> slTriggerBy)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/create");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_new does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    if (symbol)
    {
        formParams[ utility::conversions::to_string_t("symbol") ] = ApiClient::parameterToString(*symbol);
    }
    if (side)
    {
        formParams[ utility::conversions::to_string_t("side") ] = ApiClient::parameterToString(*side);
    }
    if (orderType)
    {
        formParams[ utility::conversions::to_string_t("order_type") ] = ApiClient::parameterToString(*orderType);
    }
    if (qty)
    {
        formParams[ utility::conversions::to_string_t("qty") ] = ApiClient::parameterToString(*qty);
    }
    if (price)
    {
        formParams[ utility::conversions::to_string_t("price") ] = ApiClient::parameterToString(*price);
    }
    if (basePrice)
    {
        formParams[ utility::conversions::to_string_t("base_price") ] = ApiClient::parameterToString(*basePrice);
    }
    if (stopPx)
    {
        formParams[ utility::conversions::to_string_t("stop_px") ] = ApiClient::parameterToString(*stopPx);
    }
    if (timeInForce)
    {
        formParams[ utility::conversions::to_string_t("time_in_force") ] = ApiClient::parameterToString(*timeInForce);
    }
    if (triggerBy)
    {
        formParams[ utility::conversions::to_string_t("trigger_by") ] = ApiClient::parameterToString(*triggerBy);
    }
    if (reduceOnly)
    {
        formParams[ utility::conversions::to_string_t("reduce_only") ] = ApiClient::parameterToString(*reduceOnly);
    }
    if (closeOnTrigger)
    {
        formParams[ utility::conversions::to_string_t("close_on_trigger") ] = ApiClient::parameterToString(*closeOnTrigger);
    }
    if (orderLinkId)
    {
        formParams[ utility::conversions::to_string_t("order_link_id") ] = ApiClient::parameterToString(*orderLinkId);
    }
    if (takeProfit)
    {
        formParams[ utility::conversions::to_string_t("take_profit") ] = ApiClient::parameterToString(*takeProfit);
    }
    if (stopLoss)
    {
        formParams[ utility::conversions::to_string_t("stop_loss") ] = ApiClient::parameterToString(*stopLoss);
    }
    if (tpTriggerBy)
    {
        formParams[ utility::conversions::to_string_t("tp_trigger_by") ] = ApiClient::parameterToString(*tpTriggerBy);
    }
    if (slTriggerBy)
    {
        formParams[ utility::conversions::to_string_t("sl_trigger_by") ] = ApiClient::parameterToString(*slTriggerBy);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_new does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_new: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_new: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_new: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_query(boost::optional<utility::string_t> symbol, boost::optional<utility::string_t> stopOrderId, boost::optional<utility::string_t> orderLinkId)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/search");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_query does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    if (symbol)
    {
        queryParams[utility::conversions::to_string_t("symbol")] = ApiClient::parameterToString(*symbol);
    }
    if (stopOrderId)
    {
        queryParams[utility::conversions::to_string_t("stop_order_id")] = ApiClient::parameterToString(*stopOrderId);
    }
    if (orderLinkId)
    {
        queryParams[utility::conversions::to_string_t("order_link_id")] = ApiClient::parameterToString(*orderLinkId);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_query does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_query: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_query: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_query: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<Object>> LinearConditionalApi::linearConditional_replace(utility::string_t symbol, boost::optional<utility::string_t> stopOrderId, boost::optional<utility::string_t> orderLinkId, boost::optional<utility::string_t> pRQty, boost::optional<double> pRPrice, boost::optional<double> pRTriggerPrice)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/private/linear/stop-order/replace");
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_replace does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    {
        formParams[ utility::conversions::to_string_t("symbol") ] = ApiClient::parameterToString(symbol);
    }
    if (stopOrderId)
    {
        formParams[ utility::conversions::to_string_t("stop_order_id") ] = ApiClient::parameterToString(*stopOrderId);
    }
    if (orderLinkId)
    {
        formParams[ utility::conversions::to_string_t("order_link_id") ] = ApiClient::parameterToString(*orderLinkId);
    }
    if (pRQty)
    {
        formParams[ utility::conversions::to_string_t("p_r_qty") ] = ApiClient::parameterToString(*pRQty);
    }
    if (pRPrice)
    {
        formParams[ utility::conversions::to_string_t("p_r_price") ] = ApiClient::parameterToString(*pRPrice);
    }
    if (pRTriggerPrice)
    {
        formParams[ utility::conversions::to_string_t("p_r_trigger_price") ] = ApiClient::parameterToString(*pRTriggerPrice);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("LinearConditionalApi->linearConditional_replace does not consume any supported media type"));
    }

    // authentication (apiKey) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("api_key")] = apiKey;
        }
    }
    // authentication (apiSignature) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("sign"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("sign")] = apiKey;
        }
    }
    // authentication (timestamp) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(utility::conversions::to_string_t("timestamp"));
        if ( apiKey.size() > 0 )
        {
            queryParams[utility::conversions::to_string_t("timestamp")] = apiKey;
        }
    }

    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling linearConditional_replace: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling linearConditional_replace: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling linearConditional_replace: unsupported response type"));
        }

        return result;
    });
}

}
}
}
}

