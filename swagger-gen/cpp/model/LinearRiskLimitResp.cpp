/**
 * Bybit API
 * ## REST API for the Bybit Exchange. Base URI: [https://api.bybit.com]  
 *
 * OpenAPI spec version: 0.2.10
 * Contact: support@bybit.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.8.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "LinearRiskLimitResp.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

LinearRiskLimitResp::LinearRiskLimitResp()
{
    m_Created_at = utility::conversions::to_string_t("");
    m_Created_atIsSet = false;
    m_Id = 0;
    m_IdIsSet = false;
    m_Is_lowest_risk = 0;
    m_Is_lowest_riskIsSet = false;
    m_Limit = 0L;
    m_LimitIsSet = false;
    m_Maintain_margin = 0.0;
    m_Maintain_marginIsSet = false;
    m_SectionIsSet = false;
    m_Starting_margin = 0.0;
    m_Starting_marginIsSet = false;
    m_Symbol = utility::conversions::to_string_t("");
    m_SymbolIsSet = false;
    m_Updated_at = utility::conversions::to_string_t("");
    m_Updated_atIsSet = false;
}

LinearRiskLimitResp::~LinearRiskLimitResp()
{
}

void LinearRiskLimitResp::validate()
{
    // TODO: implement validation
}

web::json::value LinearRiskLimitResp::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_Created_atIsSet)
    {
        val[utility::conversions::to_string_t("created_at")] = ModelBase::toJson(m_Created_at);
    }
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t("id")] = ModelBase::toJson(m_Id);
    }
    if(m_Is_lowest_riskIsSet)
    {
        val[utility::conversions::to_string_t("is_lowest_risk")] = ModelBase::toJson(m_Is_lowest_risk);
    }
    if(m_LimitIsSet)
    {
        val[utility::conversions::to_string_t("limit")] = ModelBase::toJson(m_Limit);
    }
    if(m_Maintain_marginIsSet)
    {
        val[utility::conversions::to_string_t("maintain_margin")] = ModelBase::toJson(m_Maintain_margin);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Section )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[utility::conversions::to_string_t("section")] = web::json::value::array(jsonArray);
        }
    }
    if(m_Starting_marginIsSet)
    {
        val[utility::conversions::to_string_t("starting_margin")] = ModelBase::toJson(m_Starting_margin);
    }
    if(m_SymbolIsSet)
    {
        val[utility::conversions::to_string_t("symbol")] = ModelBase::toJson(m_Symbol);
    }
    if(m_Updated_atIsSet)
    {
        val[utility::conversions::to_string_t("updated_at")] = ModelBase::toJson(m_Updated_at);
    }

    return val;
}

void LinearRiskLimitResp::fromJson(web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("created_at")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("created_at")];
        if(!fieldValue.is_null())
        {
            setCreatedAt(ModelBase::stringFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("id")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("id")];
        if(!fieldValue.is_null())
        {
            setId(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("is_lowest_risk")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("is_lowest_risk")];
        if(!fieldValue.is_null())
        {
            setIsLowestRisk(ModelBase::int32_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("limit")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("limit")];
        if(!fieldValue.is_null())
        {
            setLimit(ModelBase::int64_tFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("maintain_margin")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("maintain_margin")];
        if(!fieldValue.is_null())
        {
            setMaintainMargin(ModelBase::doubleFromJson(fieldValue));
        }
    }
    {
        m_Section.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(utility::conversions::to_string_t("section")))
        {
        for( auto& item : val[utility::conversions::to_string_t("section")].as_array() )
        {
            m_Section.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    if(val.has_field(utility::conversions::to_string_t("starting_margin")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("starting_margin")];
        if(!fieldValue.is_null())
        {
            setStartingMargin(ModelBase::doubleFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("symbol")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("symbol")];
        if(!fieldValue.is_null())
        {
            setSymbol(ModelBase::stringFromJson(fieldValue));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("updated_at")))
    {
        web::json::value& fieldValue = val[utility::conversions::to_string_t("updated_at")];
        if(!fieldValue.is_null())
        {
            setUpdatedAt(ModelBase::stringFromJson(fieldValue));
        }
    }
}

void LinearRiskLimitResp::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_Created_atIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("created_at"), m_Created_at));
        
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("id"), m_Id));
    }
    if(m_Is_lowest_riskIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("is_lowest_risk"), m_Is_lowest_risk));
    }
    if(m_LimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("limit"), m_Limit));
    }
    if(m_Maintain_marginIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("maintain_margin"), m_Maintain_margin));
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Section )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("section"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
        }
    }
    if(m_Starting_marginIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("starting_margin"), m_Starting_margin));
    }
    if(m_SymbolIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("symbol"), m_Symbol));
        
    }
    if(m_Updated_atIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("updated_at"), m_Updated_at));
        
    }
}

void LinearRiskLimitResp::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("created_at")))
    {
        setCreatedAt(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("created_at"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("id")))
    {
        setId(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("id"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("is_lowest_risk")))
    {
        setIsLowestRisk(ModelBase::int32_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("is_lowest_risk"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("limit")))
    {
        setLimit(ModelBase::int64_tFromHttpContent(multipart->getContent(utility::conversions::to_string_t("limit"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("maintain_margin")))
    {
        setMaintainMargin(ModelBase::doubleFromHttpContent(multipart->getContent(utility::conversions::to_string_t("maintain_margin"))));
    }
    {
        m_Section.clear();
        if(multipart->hasContent(utility::conversions::to_string_t("section")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("section"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_Section.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    if(multipart->hasContent(utility::conversions::to_string_t("starting_margin")))
    {
        setStartingMargin(ModelBase::doubleFromHttpContent(multipart->getContent(utility::conversions::to_string_t("starting_margin"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("symbol")))
    {
        setSymbol(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("symbol"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("updated_at")))
    {
        setUpdatedAt(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("updated_at"))));
    }
}

utility::string_t LinearRiskLimitResp::getCreatedAt() const
{
    return m_Created_at;
}


void LinearRiskLimitResp::setCreatedAt(utility::string_t value)
{
    m_Created_at = value;
    m_Created_atIsSet = true;
}
bool LinearRiskLimitResp::createdAtIsSet() const
{
    return m_Created_atIsSet;
}

void LinearRiskLimitResp::unsetCreated_at()
{
    m_Created_atIsSet = false;
}

int32_t LinearRiskLimitResp::getId() const
{
    return m_Id;
}


void LinearRiskLimitResp::setId(int32_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}
bool LinearRiskLimitResp::idIsSet() const
{
    return m_IdIsSet;
}

void LinearRiskLimitResp::unsetId()
{
    m_IdIsSet = false;
}

int32_t LinearRiskLimitResp::getIsLowestRisk() const
{
    return m_Is_lowest_risk;
}


void LinearRiskLimitResp::setIsLowestRisk(int32_t value)
{
    m_Is_lowest_risk = value;
    m_Is_lowest_riskIsSet = true;
}
bool LinearRiskLimitResp::isLowestRiskIsSet() const
{
    return m_Is_lowest_riskIsSet;
}

void LinearRiskLimitResp::unsetIs_lowest_risk()
{
    m_Is_lowest_riskIsSet = false;
}

int64_t LinearRiskLimitResp::getLimit() const
{
    return m_Limit;
}


void LinearRiskLimitResp::setLimit(int64_t value)
{
    m_Limit = value;
    m_LimitIsSet = true;
}
bool LinearRiskLimitResp::limitIsSet() const
{
    return m_LimitIsSet;
}

void LinearRiskLimitResp::unsetLimit()
{
    m_LimitIsSet = false;
}

double LinearRiskLimitResp::getMaintainMargin() const
{
    return m_Maintain_margin;
}


void LinearRiskLimitResp::setMaintainMargin(double value)
{
    m_Maintain_margin = value;
    m_Maintain_marginIsSet = true;
}
bool LinearRiskLimitResp::maintainMarginIsSet() const
{
    return m_Maintain_marginIsSet;
}

void LinearRiskLimitResp::unsetMaintain_margin()
{
    m_Maintain_marginIsSet = false;
}

std::vector<utility::string_t>& LinearRiskLimitResp::getSection()
{
    return m_Section;
}

void LinearRiskLimitResp::setSection(std::vector<utility::string_t> value)
{
    m_Section = value;
    m_SectionIsSet = true;
}
bool LinearRiskLimitResp::sectionIsSet() const
{
    return m_SectionIsSet;
}

void LinearRiskLimitResp::unsetSection()
{
    m_SectionIsSet = false;
}

double LinearRiskLimitResp::getStartingMargin() const
{
    return m_Starting_margin;
}


void LinearRiskLimitResp::setStartingMargin(double value)
{
    m_Starting_margin = value;
    m_Starting_marginIsSet = true;
}
bool LinearRiskLimitResp::startingMarginIsSet() const
{
    return m_Starting_marginIsSet;
}

void LinearRiskLimitResp::unsetStarting_margin()
{
    m_Starting_marginIsSet = false;
}

utility::string_t LinearRiskLimitResp::getSymbol() const
{
    return m_Symbol;
}


void LinearRiskLimitResp::setSymbol(utility::string_t value)
{
    m_Symbol = value;
    m_SymbolIsSet = true;
}
bool LinearRiskLimitResp::symbolIsSet() const
{
    return m_SymbolIsSet;
}

void LinearRiskLimitResp::unsetSymbol()
{
    m_SymbolIsSet = false;
}

utility::string_t LinearRiskLimitResp::getUpdatedAt() const
{
    return m_Updated_at;
}


void LinearRiskLimitResp::setUpdatedAt(utility::string_t value)
{
    m_Updated_at = value;
    m_Updated_atIsSet = true;
}
bool LinearRiskLimitResp::updatedAtIsSet() const
{
    return m_Updated_atIsSet;
}

void LinearRiskLimitResp::unsetUpdated_at()
{
    m_Updated_atIsSet = false;
}

}
}
}
}

